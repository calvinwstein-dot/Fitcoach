  Future<void> _speak(String text) async {
    print('üé§ _speak called with: "$text"');
    
    if (_serverUrl.isEmpty) {
      print('‚ùå No server URL configured');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('‚ùå No TTS server configured')),
        );
      }
      return;
    }
    
    // Try multiple endpoints and parameter formats
    final testConfigs = [
      {'endpoint': '/tts.mp3', 'params': 'text=${Uri.encodeComponent(text)}&voice=$_selectedVoice'},
      {'endpoint': '/tts', 'params': 'text=${Uri.encodeComponent(text)}&voice=$_selectedVoice'},
      {'endpoint': '/tts.mp3', 'params': 'text=${Uri.encodeComponent(text)}&voiceId=$_selectedVoice'},
      {'endpoint': '/tts', 'params': 'text=${Uri.encodeComponent(text)}&voiceId=$_selectedVoice'},
      {'endpoint': '/tts.mp3', 'params': 'text=${Uri.encodeComponent(text)}'},
      {'endpoint': '/tts', 'params': 'text=${Uri.encodeComponent(text)}'},
    ];
    Uri? workingUri;
    
    for (final config in testConfigs) {
      final testUri = Uri.parse('${_serverUrl}${config['endpoint']}?${config['params']}');
      print('üîä Testing TTS config: $testUri');
    
      try {
        print('üîç Testing server response...');
        final response = await http.get(testUri);
        print('üì° Server response status: ${response.statusCode}');
        print('üì° Server response headers: ${response.headers}');
        
        if (response.statusCode == 200) {
          // Check if response is actually audio
          final contentType = response.headers['content-type'] ?? '';
          if (contentType.contains('audio') || contentType.contains('mpeg')) {
            print('‚úÖ Found working config: ${config['endpoint']}');
            workingUri = testUri;
            break;
          } else {
            print('‚ùå Config returned non-audio content: $contentType');
            print('‚ùå Response body: ${response.body}');
          }
        } else {
          print('‚ùå Config returned ${response.statusCode}: ${response.body}');
        }
        
      } catch (configError) {
        print('‚ùå Config ${config['endpoint']} failed: $configError');
      }
    }
    
    if (workingUri == null) {
      print('‚ùå No working TTS endpoints found');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('‚ùå TTS Server: No working endpoints found'),
            backgroundColor: Colors.red,
            duration: Duration(seconds: 5),
          ),
        );
      }
      return;
    }
    
    print('‚úÖ Using working endpoint: $workingUri');
    
    try {
      // Stop any currently playing audio
      _audioElement?.pause();
      _audioElement = null;
      
      // Create new audio element
      _audioElement = html.AudioElement();
      _audioElement!.crossOrigin = 'anonymous';
      _audioElement!.preload = 'metadata';
      
      // Set up event listeners for debugging
      _audioElement!.onLoadedData.listen((_) => print('üéµ Audio loaded'));
      _audioElement!.onCanPlay.listen((_) => print('üéµ Audio can play'));
      _audioElement!.onPlaying.listen((_) => print('üéµ Audio playing'));
      _audioElement!.onEnded.listen((_) => print('üéµ Audio ended'));
      _audioElement!.onError.listen((e) => print('‚ùå Audio error: $e'));
      
      // Set source and play
      _audioElement!.src = workingUri.toString();
      
      // Use a promise-based approach for better error handling
      try {
        await _audioElement!.play();
        print('‚úÖ Audio playback started successfully');
        
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('üîä Playing: "${text.length > 30 ? text.substring(0, 30) + '...' : text}"'),
              backgroundColor: Colors.green.withOpacity(0.8),
              duration: const Duration(seconds: 2),
            ),
          );
        }
        
      } catch (playError) {
        print('‚ùå Play failed: $playError');
        
        // Fallback: Try with a small delay to ensure user gesture is recognized
        await Future.delayed(const Duration(milliseconds: 100));
        await _audioElement!.play();
        print('‚úÖ Audio playback started after delay');
        
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('üîä Playing (delayed): "${text.length > 30 ? text.substring(0, 30) + '...' : text}"'),
              backgroundColor: Colors.orange.withOpacity(0.8),
              duration: const Duration(seconds: 2),
            ),
          );
        }
      }
      
    } catch (e) {
      print('‚ùå Audio completely failed: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('‚ùå Audio failed: ${e.toString()}'),
            backgroundColor: Colors.red.withOpacity(0.8),
            duration: const Duration(seconds: 3),
          ),
        );
      }
    }
  }



